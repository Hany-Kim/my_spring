package hellojpa;

import jakarta.persistence.DiscriminatorColumn;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.Inheritance;
import jakarta.persistence.InheritanceType;

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item {

    /*
    * 조인 전략 -> 기본적인 정석(객체랑 잘 맞다.)
    * 장점
    *   - 데이터가 정규화 되어 있다.
    *   - 제약조건을 Item에만 걸어서 맞출 수 있다.
    *   - 가격으로 정산할 때, Item테이블만 확인하면 된다.
    *   - 외래키 참조 무결성 제약조건을 사용할 수 있다.
    *   - 저장공간 효율화
    * 단점
    *   - 조회시 조인을 많이해야 사용, 성능 저하
    *   - 조회 쿼리가 복잡함 -> 큰 단점은 아님.
    *   - 데이터 저장시 Insert쿼리가 2번 나감 -> 큰 단점은 아님.
    * : 큰 단점은 아니지만 싱글 테이블 전략과 비교해 단점임.
    * --------------------------------------------------------
    * 싱글 테이블 전략
    * 장점
    *   - 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
    *   - 조회 쿼리가 단순함
    * 단점
    *   - 자식 엔티티가 매핑한 컬럼은 모두 Null 허용 -> 치명적인 단점임. 데이터 무결성 측면
    *   - 단일 테이블에 모든것을 저장하므로 테이블이 커질 수 있음.
    *       상황에 따라서는 조인 테이블 전략에 비해 조회 성능이 떨어질 수 있다. -> 일반적으로는 빠르다.
    * --------------------------------------------------------
    * 구현 클래스마다 테이블 전략 -> 결론적으로 비추(사용하면 안되는 전략)
    * : 이 전략은 DB설계자와 ORM전문가 둘 다 추천 x
    * : 묶여 있는게 없다. ex. PRICE가 각 테이블에 존재하기 때문에 정산시스템 구축시 다 따로 구현해야한다.
    * 장점
    *   - 서브 타입을 명확하게 구분해서 처리할 때 효과적
    *   - not null 제약조건 사용 가능
    * 단점
    *   - 여러 자식 테이블을 함께 조회할 때 성능이 느림 (UNION SQL)
    *   - 자식 테이블을 통합해서 쿼리하기 어려움
    *   - 시스템 변경시 고쳐야할게 많다.
    * */

    @Id @GeneratedValue(strategy = GenerationType.TABLE)
    private Long id;

    private String name;
    private int price;

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPrice() {
        return price;
    }

    public void setPrice(int price) {
        this.price = price;
    }

    /*
    * JPA는 기본전략이 싱글 테이블로 구성되게 한다.
    * 싱글 테이블 전략은 @DiscriminatorColumn을 추가하지 않아도 DTYPE이 필수로 추가되어 있다.
    * 싱글 테이블 전략은 데이터 조회만으로 판별하기 힘들기 때문
    *
    * create table Item (
        price integer not null,
        id bigint generated by default as identity,
        DTYPE varchar(31) not null,
        actor varchar(255),
        artist varchar(255),
        author varchar(255),
        director varchar(255),
        isbn varchar(255),
        name varchar(255),
        primary key (id)
    )
    *
    * 조인 전략을 사용하기 위해서는
    * @Inheritance(strategy = InheritanceType.JOINED) 를 추가한다.
    * */

    /*
    * @DiscriminatorColumn을 추가하면 DTYPE이 테이블에 추가된것을 확인할 수 있다.
    * DTYPE은 Entity 이름이 들어간다. -> 운영측면에서 왠만하면 추가하는 편이 좋다.
    *
    * create table Item (
        price integer not null,
        id bigint generated by default as identity,
        DTYPE varchar(31) not null,
        name varchar(255),
        primary key (id)
    )
    *
    * */

    /*
    * TABLE_PER_CLASS 전략을 사용하면
    * 슈퍼타입 테이블(추상 테이블(Item))을 두지 않고, 각 서브타입(Entity)에 공통 Column을 각각 추가하여 관리
    * Item 테이블은 생기지 않는다.
    *
    * create table Album (
        price integer not null,
        id bigint not null,
        artist varchar(255),
        name varchar(255),
        primary key (id)
    )
    * create table Book (
        price integer not null,
        id bigint not null,
        author varchar(255),
        isbn varchar(255),
        name varchar(255),
        primary key (id)
    )
    * create table Movie (
        price integer not null,
        id bigint not null,
        actor varchar(255),
        director varchar(255),
        name varchar(255),
        primary key (id)
    )
    * */
}
